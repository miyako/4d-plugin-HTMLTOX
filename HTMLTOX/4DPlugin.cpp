/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : HTMLTOX
 #	author : miyako
 #	2016/11/21
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

NSString *launchPath;

NSArray *copySources(ARRAY_TEXT &inObjects)
{
	NSMutableArray *sources = [[NSMutableArray alloc]init];
			
	for(NSUInteger i = 0; i < inObjects.getSize(); ++i){
	
		NSString *source = inObjects.copyUTF16StringAtIndex(i);
		
		if( [source hasPrefix:@"http://"]
			||[source hasPrefix:@"ftp://"]
			||[source hasPrefix:@"https://"]
			||[source hasPrefix:@"file://"]
			)
		{
			// the sources is a url
			NSDictionary *item = [[NSDictionary alloc]initWithObjectsAndKeys:
			 source, @"data",
			 @"url", @"type", nil];
			[sources addObject:item];
			[item release];
			
		}else{
		
			// the sources is a path
			NSString *path = inObjects.copyPathAtIndex(i);
			if([[NSFileManager defaultManager]fileExistsAtPath:path])
			{
				NSDictionary *item = [[NSDictionary alloc]initWithObjectsAndKeys:
																path, @"data",
																@"path", @"type",
																nil];
				[sources addObject:item];
				[item release];
				
			}else{
			//the sources is html
				NSDictionary *item = [[NSDictionary alloc]initWithObjectsAndKeys:
																path, @"data",
																@"html", @"type",
																nil];
				[sources addObject:item];
				[item release];
			}
			[path release];
		}
		[source release];
	}
	return sources;
}

NSNumber *getFormat(C_LONGINT &inOutputFormat)
{
	int fmt = inOutputFormat.getIntValue();
	switch (fmt)
	{
		case HTMLTOX_Format_PDF:
		case HTMLTOX_Format_PS:
		case HTMLTOX_Format_PNG:
		case HTMLTOX_Format_JPG:
		case HTMLTOX_Format_BMP:
		case HTMLTOX_Format_SVG:
			break;
		default:
			fmt = HTMLTOX_Format_PDF;
			break;
	};
	return [NSNumber numberWithInt:fmt];
}

NSArray *copyOptions(ARRAY_TEXT &inOptionName, ARRAY_TEXT &inOptionValue)
{
	NSMutableArray *options = [[NSMutableArray alloc]init];
	
	size_t countOptions = inOptionName.getSize();
	if(countOptions == inOptionValue.getSize())
	{
		for(NSUInteger i = 0; i < countOptions; ++i)
		{
			NSString *name = inOptionName.copyUTF16StringAtIndex(i);
			NSString *value = inOptionValue.copyUTF16StringAtIndex(i);
			NSDictionary *option = [[NSDictionary alloc]initWithObjectsAndKeys:
															name, @"name",
															value, @"value",
															nil];
			[options addObject:option];
			[option release];
			[name release];
			[value release];
		}
	}
	
	return options;
}

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void LaunchHelper()
{
	NSConnection *connection = [NSConnection connectionWithRegisteredName:HTMLTOX_CONNECTION_NAME host:nil];
	
	if(!connection)
	{
		if([[NSWorkspace sharedWorkspace]launchApplication:launchPath])
		{
			NSLog(@"launched appliation: %@\n", launchPath);
			PA_long32 pid = PA_GetCurrentProcessNumber();
			
			for(int i = 1; 1 < 100; ++i)
			{
				PA_PutProcessToSleep(pid, 6);
				connection = [NSConnection connectionWithRegisteredName:HTMLTOX_CONNECTION_NAME host:nil];
				if(connection) break;
			}
			
			if(!connection)
			{
				NSLog(@"failed to launch appliation: %@\n", launchPath);
			}
			
		}else
		{
			NSLog(@"failed to launch appliation: %@\n", launchPath);
		}
	}else
	{
		NSLog(@"connection is ready: %@\n", HTMLTOX_CONNECTION_NAME);
	}
}

void StopHelper()
{
	NSConnection *connection = [NSConnection connectionWithRegisteredName:HTMLTOX_CONNECTION_NAME host:nil];
	
	if(connection)
	{
		HTMLTOX *htmltox = (HTMLTOX *)[connection rootProxy];
		[htmltox quit];
	}else
	{
		NSLog(@"connection already dead: %@\n", HTMLTOX_CONNECTION_NAME);
	}
}

void OnStartup()
{
	NSBundle *bundle = [NSBundle bundleWithIdentifier:@"com.4D.4DPlugin.HTMLTOX-4"];
	
	if(bundle)
	{
		launchPath = [[[bundle executablePath]stringByDeletingLastPathComponent]
														 stringByAppendingPathComponent:@"wkhtmltox-4d"];
		
		LaunchHelper();
	}
}

void OnExit()
{
	StopHelper();
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		OnExit();
	}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
			
// --- HTMLTOX

		case 1 :
			HTML_Convert(pResult, pParams);
			break;

	}
}

#pragma mark -

// ------------------------------------ HTMLTOX -----------------------------------

void HTML_Convert(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT inObjects;
	C_LONGINT inOutputFormat;
	ARRAY_TEXT inOptionName;
	ARRAY_TEXT inOptionValue;
	C_BLOB returnValue;
	
	inObjects.fromParamAtIndex(pParams, 1);
	inOutputFormat.fromParamAtIndex(pParams, 2);
	inOptionName.fromParamAtIndex(pParams, 3);
	inOptionValue.fromParamAtIndex(pParams, 4);

	NSArray *sources = copySources(inObjects);
	NSNumber *format = getFormat(inOutputFormat);
	NSArray *options = copyOptions(inOptionName, inOptionValue);

	LaunchHelper();
	
	NSConnection *connection = [NSConnection connectionWithRegisteredName:HTMLTOX_CONNECTION_NAME host:nil];
	
	if(connection)
	{
		HTMLTOX *htmltox = (HTMLTOX *)[connection rootProxy];
		
		NSData *data = [htmltox doIt:sources
													format:format
												 options:options];
		
		returnValue.setBytes((const uint8_t *)[data bytes], [data length]);
	}
	
	[sources release];
	
	returnValue.setReturn(pResult);
}