/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : HTMLTOX
 #	author : miyako
 #	2016/11/21
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

#pragma mark -
//
//int test(const char *src){
//	
//	int page_num = 0;
//	
//	CFStringRef c = CFStringCreateWithCString(kCFAllocatorDefault, src, kCFStringEncodingUTF8);
//	if(c)
//	{
//		CFRange r = CFStringFind(c, CFSTR(":"), 0);
//		if(r.location != kCFNotFound)
//		{
//			CFStringRef n = CFStringCreateWithSubstring(kCFAllocatorDefault, c, CFRangeMake(0, r.location));
//			if(n)
//			{
//				page_num = CFStringGetIntValue(n);
//				
//				CFStringRef m = CFStringCreateWithSubstring(kCFAllocatorDefault, c, CFRangeMake(r.location+1, CFStringGetLength(c) - r.location+1));
//				
//				if(m)
////				{
//					CFRelease(m);
//				}
//				
//				CFRelease(n);
//			}
//		}
//		CFRelease(c);
//	}
//	return page_num;
//}


namespace HTMLTOX
{
	std::vector<CUTF16String>CALLBACK_PARAM_TYPE;
	std::vector<CUTF16String>CALLBACK_PARAM_STR;
	std::vector<int>CALLBACK_PARAM_INT;
	std::vector<int>CALLBACK_PARAM_PID;
	std::map<int, int> PROGRESS_PID;
	
	void append(CUTF16String &utype, CUTF16String &ustr, int val, int pid)
	{
		CALLBACK_PARAM_TYPE.push_back(utype);
		CALLBACK_PARAM_STR.push_back(ustr);
		CALLBACK_PARAM_INT.push_back(val);
		CALLBACK_PARAM_PID.push_back(pid);
	}
	
	void clear()
	{
		CALLBACK_PARAM_TYPE.clear();
		CALLBACK_PARAM_STR.clear();
		CALLBACK_PARAM_INT.clear();
		CALLBACK_PARAM_PID.clear();
		PROGRESS_PID.clear();
	}
	
	void erase(int processId)
	{
		auto t = HTMLTOX::CALLBACK_PARAM_TYPE.begin();
		auto s = HTMLTOX::CALLBACK_PARAM_STR.begin();
		auto i = HTMLTOX::CALLBACK_PARAM_INT.begin();
		auto p = HTMLTOX::CALLBACK_PARAM_PID.begin();
		
		while (p != CALLBACK_PARAM_PID.end())
		{
			if(*p == processId)
			{
				t = CALLBACK_PARAM_TYPE.erase(t);
				s = CALLBACK_PARAM_STR.erase(s);
				i = CALLBACK_PARAM_INT.erase(i);
				p = CALLBACK_PARAM_PID.erase(p);
			}
			else
			{
				++t;
				++s;
				++i;
				++p;
			}
		}
	}
	
	void clear(int processId)
	{
		auto it = PROGRESS_PID.find(processId);
		if(it != PROGRESS_PID.end()) {
			PROGRESS_PID.erase(it);
		}
		erase(processId);
	}
	
	int getProgressForProcess(int processId)
	{
		auto it = PROGRESS_PID.find(processId);
		if(it != PROGRESS_PID.end()) {
			return it->second;
		}
		return 0;
	}
	
	void setProgressForProcess(int processId, int progress)
	{
		PROGRESS_PID[processId] = progress;
	}
}

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{
	CFNotificationCenterRef center = CFNotificationCenterGetDistributedCenter();
	
	if(center)
	{
		CFNotificationCenterAddObserver(center,
																		NULL,
																		notificationCallback,
																		htmltox_notification_name,
																		NULL,
																		CFNotificationSuspensionBehaviorDeliverImmediately);
	}
	HTMLTOX::clear();
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
		CFNotificationCenterRef center = CFNotificationCenterGetDistributedCenter();
		
		if(center)
		{
			CFNotificationCenterRemoveObserver(center, NULL, htmltox_notification_name, NULL);
		}
	}
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
			
// --- HTMLTOX

		case 1 :
			HTML_Convert(pResult, pParams);
			break;

	}
}

#pragma mark -

// ------------------------------------ HTMLTOX -----------------------------------

void setString(NSString* src, CUTF16String &dst)
{
	if(src)
	{
		uint32_t len = [src length];
		uint32_t size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
		std::vector<uint8_t> buf(size);
		if([src getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding])
		{
			dst = CUTF16String((const PA_Unichar *)&buf[0], len);
		}
	}
}

void notificationCallback(CFNotificationCenterRef center,
													void * observer,
													CFStringRef name,
													const void * object,
													CFDictionaryRef userInfo)
{

	NSString *type = (NSString *)CFDictionaryGetValue(userInfo, CFSTR("type"));
	int val = [(NSNumber *)CFDictionaryGetValue(userInfo, CFSTR("val")) intValue];
	int pid = [(NSNumber *)CFDictionaryGetValue(userInfo, CFSTR("pid")) intValue];
	NSString *str = (NSString *)CFDictionaryGetValue(userInfo, CFSTR("str"));
	
	CUTF16String utype, ustr;
	setString(type, utype);
	setString(str, ustr);

	if([type isEqualToString:@"progress"])
	{
		int progress = HTMLTOX::getProgressForProcess(pid);
		
		if(progress < val)
		{
			HTMLTOX::append(utype, ustr, val, pid);
			HTMLTOX::setProgressForProcess(pid, val);
//			NSLog(@"type:%@ val:%i pid:%i str:%@", type, val, pid, str);
		}
	}else if([type isEqualToString:@"info"])
	{
//		NSLog(@"type:%@ val:%i pid:%i str:%@", type, val, pid, str);
	}else
	{
		HTMLTOX::append(utype, ustr, val, pid);
//		NSLog(@"type:%@ val:%i pid:%i str:%@", type, val, pid, str);
	}
}

void HTML_Convert(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT inObjects;
	C_LONGINT inOutputFormat;
	ARRAY_TEXT inOptionName;
	ARRAY_TEXT inOptionValue;
	C_BLOB returnValue;
	
	inObjects.fromParamAtIndex(pParams, 1);
	inOutputFormat.fromParamAtIndex(pParams, 2);
	inOptionName.fromParamAtIndex(pParams, 3);
	inOptionValue.fromParamAtIndex(pParams, 4);

	CUTF16String methodName;
	int progressId = 0;
	int currentProcessId = PA_GetCurrentProcessNumber();
	
	NSBundle *bundle = [NSBundle bundleWithIdentifier:this_bundle_id];
	if(bundle)
	{
		NSString *currentDirectoryPath = [[bundle executablePath]stringByDeletingLastPathComponent];
		NSString *launchPath = [currentDirectoryPath stringByAppendingPathComponent:@"wkhtmltox-4d"];
		
		NSTask *task = [[NSTask alloc]init];
		[task setCurrentDirectoryPath:currentDirectoryPath];
		[task setLaunchPath:launchPath];
		
		//options
		size_t countOptions = inOptionName.getSize();
		if(countOptions == inOptionValue.getSize())
		{
			NSMutableArray *arguments = [[NSMutableArray alloc]init];
			
			BOOL isOutputPDF = false;
			int outputFormat = inOutputFormat.getIntValue();
			
			switch (outputFormat)
			{
				case HTMLTOX_Format_PDF:
				case HTMLTOX_Format_PS:
					isOutputPDF = true;
					break;
				case HTMLTOX_Format_PNG:
				case HTMLTOX_Format_JPG:
				case HTMLTOX_Format_BMP:
				case HTMLTOX_Format_SVG:
					isOutputPDF = false;
					break;
				default:
					outputFormat = HTMLTOX_Format_PDF;
					isOutputPDF = true;
					break;
			};
			
			[arguments addObject:@"fmt"];
			[arguments addObject:[NSString stringWithFormat:@"%i", outputFormat]];

			[arguments addObject:@"pid"];
			[arguments addObject:[NSString stringWithFormat:@"%i", currentProcessId]];
			
			int countPages = inObjects.getSize();
			
			if(!isOutputPDF)
			{
				countPages = countPages ? 2 : 0;
			}
			
			for(int i = 1; i < countPages; ++i)
			{
				CUTF8String htmlObject;
				inObjects.copyUTF8StringAtIndex(&htmlObject, i);
				//object can be a url, a path
				//html source is disabled
				if(
					 !((htmlObject.find((const uint8_t *)"http://") == 0)
					 ||(htmlObject.find((const uint8_t *)"ftp://") == 0)
					 ||(htmlObject.find((const uint8_t *)"https://") == 0)
					 ||(htmlObject.find((const uint8_t *)"file://") == 0)
					 ))
				{
					//system path?
					NSString *str = inObjects.copyUTF16StringAtIndex(i);
					NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)str, kCFURLHFSPathStyle, false);
					if(url)
					{
						NSString *src = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
						[arguments addObject:@"src"];
						[arguments addObject:src];
						[src release];
						[url release];
					}
					[str release];
				}else{
					NSString *src = inObjects.copyUTF16StringAtIndex(i);
					[arguments addObject:@"src"];
					[arguments addObject:src];
					[src release];
				}
			}
			
			for(int i = 0; i < countOptions; ++i)
			{
				CUTF8String optionName, optionValue;
				inOptionName.copyUTF8StringAtIndex(&optionName, i);
				inOptionValue.copyUTF8StringAtIndex(&optionValue, i);
				if(optionName.find((const uint8_t *)"4d.callbackMethodName") == 0)
				{
					inOptionValue.copyUTF16StringAtIndex(&methodName, i);
				}else if(optionName.find((const uint8_t *)"4d.progressId") == 0)
				{
					progressId = atoi((const char *)optionValue.c_str());
				}else
				{
					NSString *argName = inOptionName.copyUTF16StringAtIndex(i);
					NSString *argValue = inOptionValue.copyUTF16StringAtIndex(i);
					[arguments addObject:@"arg"];
					[arguments addObject:argName];
					[arguments addObject:argValue];
					[argName release];
					[argValue release];
				}
			}
			//NSLog(@"%@", [arguments description]);
			[task setArguments:arguments];
		}
		
		NSPipe *pStdOout = [NSPipe pipe];
		[task setStandardOutput:pStdOout];
		NSFileHandle *fStdOout = [pStdOout fileHandleForReading];
		NSMutableData *buf = [[NSMutableData alloc]init];
		
		[fStdOout setReadabilityHandler:^(NSFileHandle *file) {
			[buf appendData:[file availableData]];
			
		}];

		HTMLTOX::clear(currentProcessId);	//this will reset the progress too
		
		[task launch];
	
		PA_long32 methodId = PA_GetMethodID((PA_Unichar *)methodName.c_str());
		
		while ([task isRunning]) {
			
			PA_YieldAbsolute();
			
			std::vector<int>::iterator p = std::find(HTMLTOX::CALLBACK_PARAM_PID.begin(), HTMLTOX::CALLBACK_PARAM_PID.end(), currentProcessId);
			
			while (p != HTMLTOX::CALLBACK_PARAM_PID.end())
			{
				PA_YieldAbsolute();
				
				size_t pos = p - HTMLTOX::CALLBACK_PARAM_PID.begin();
				CUTF16String type = HTMLTOX::CALLBACK_PARAM_TYPE.at(pos);
				CUTF16String str = HTMLTOX::CALLBACK_PARAM_STR.at(pos);
				int val = HTMLTOX::CALLBACK_PARAM_INT.at(pos);

					PA_Variable	params[5];
					params[0] = PA_CreateVariable(eVK_Longint);
					params[1] = PA_CreateVariable(eVK_Longint);
					params[2] = PA_CreateVariable(eVK_Longint);
					params[3] = PA_CreateVariable(eVK_Unistring);
					params[4] = PA_CreateVariable(eVK_Unistring);
					
					PA_Unistring utype = PA_CreateUnistring((PA_Unichar *)type.c_str());
					PA_Unistring ustr = PA_CreateUnistring((PA_Unichar *)str.c_str());
					
					PA_SetLongintVariable(&params[0], val);
					PA_SetLongintVariable(&params[1], currentProcessId);
					PA_SetLongintVariable(&params[2], progressId);
					PA_SetStringVariable(&params[3], &ustr);
					PA_SetStringVariable(&params[4], &utype);
					
					if(methodId){
						PA_ExecuteMethodByID(methodId, params, 5);
					}
					
					PA_ClearVariable(&params[0]);
					PA_ClearVariable(&params[1]);
					PA_ClearVariable(&params[2]);
					PA_ClearVariable(&params[3]);
					PA_ClearVariable(&params[4]);

				p = std::find(++p, HTMLTOX::CALLBACK_PARAM_PID.end(), currentProcessId);
				
			}	//while
			
			HTMLTOX::erase(currentProcessId);
			
		}	//while
		
		if([task terminationReason] == NSTaskTerminationReasonExit)
		{
				returnValue.addBytes((const uint8_t *)[buf bytes], [buf length]);
		}
		
		HTMLTOX::clear(currentProcessId);	//this will reset the progress too
		
		[task release];
	}	//bundle
	
	returnValue.setReturn(pResult);
}

